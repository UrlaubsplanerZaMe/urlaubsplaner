<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Urlaubsplaner</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    body { margin:0; }
    #map { height:100vh; }

    .card{
      position:absolute; top:14px; left:14px; z-index:1000;
      width:340px; max-width:calc(100vw - 28px);
      background:rgba(255,255,255,0.95);
      border-radius:18px; padding:14px;
      box-shadow:0 16px 40px rgba(0,0,0,0.18);
      font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
    }
    .row{ display:flex; gap:6px; margin-bottom:8px; }
    .btn{
      padding:10px; border-radius:12px; border:0; font-weight:800;
      cursor:pointer; width:100%;
    }
    .gray{ background:#eee; }
    .blue{ background:#0a84ff; color:#fff; }

    .field{
      width:100%; box-sizing:border-box;
      padding:12px; border-radius:12px;
      border:1px solid #ddd; margin-bottom:8px;
      font-size:14px; outline:none;
      background:#fff;
    }
    .meta{ font-size:13px; margin-top:8px; }
    .hint{ font-size:12px; opacity:.75; margin-top:6px; }
    .stopRow{ display:flex; gap:6px; align-items:center; margin-bottom:8px; }
    .xbtn{ width:44px; }
  </style>
</head>
<body>

<div class="card">
  <div class="row">
    <button class="btn gray" onclick="setMapMode('start')">Start wählen</button>
    <button class="btn gray" onclick="setMapMode('stop')">Stopp wählen</button>
    <button class="btn gray" onclick="setMapMode('ziel')">Ziel wählen</button>
  </div>

  <input id="startAddr" class="field" placeholder="Startadresse" />

  <div id="stops"></div>
  <button class="btn gray" onclick="addStop()">+ Stopp</button>

  <input id="endAddr" class="field" placeholder="Zieladresse" />

  <button class="btn blue" onclick="buildRoute()">Route berechnen</button>

  <div class="meta" id="meta"></div>
  <div class="hint">Tipp: Marker kann man ziehen. Danach wird die Adresse automatisch angepasst.</div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  // ---------------- Map ----------------
  const map = L.map('map').setView([51.1657, 10.4515], 6);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

  let mapMode = null;
  function setMapMode(mode){ mapMode = mode; }

  // ---------------- UI helpers ----------------
  const stopsDiv = document.getElementById("stops");
  const metaEl = document.getElementById("meta");

  // Stop inputs + related markers
  // Each stop has: { inputEl, marker }
  let stopItems = [];

  function addStop(prefillText = "", latlng = null){
    const row = document.createElement("div");
    row.className = "stopRow";

    const input = document.createElement("input");
    input.className = "field";
    input.placeholder = "Stopp";
    input.value = prefillText;

    const del = document.createElement("button");
    del.className = "btn gray xbtn";
    del.textContent = "X";
    del.onclick = () => {
      // remove marker if exists
      const idx = stopItems.findIndex(si => si.inputEl === input);
      if(idx >= 0){
        if(stopItems[idx].marker) map.removeLayer(stopItems[idx].marker);
        stopItems.splice(idx, 1);
      }
      row.remove();
    };

    row.appendChild(input);
    row.appendChild(del);
    stopsDiv.appendChild(row);

    const item = { inputEl: input, marker: null };
    stopItems.push(item);

    // If we have latlng -> create draggable marker bound to this stop
    if(latlng){
      item.marker = createDraggableMarker(latlng, "Stopp", async (newLatLng) => {
        const addr = await reverseGeocode(newLatLng.lat, newLatLng.lng);
        input.value = addr;
      });
    }

    return item;
  }

  // ---------------- Markers ----------------
  let startMarker = null;
  let endMarker = null;

  function createDraggableMarker(latlng, label, onMoved){
    const m = L.marker(latlng, { draggable: true }).addTo(map).bindPopup(label);

    m.on("dragend", async () => {
      const p = m.getLatLng();
      try {
        const addr = await reverseGeocode(p.lat, p.lng);
        if(onMoved) await onMoved(p, addr);
      } catch (e) {
        // fallback: just lat,lng
        if(onMoved) await onMoved(p, `${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`);
      }
    });

    return m;
  }

  // ---------------- Click on map ----------------
  map.on("click", async (e) => {
    if(!mapMode) return;

    const addr = await reverseGeocode(e.latlng.lat, e.latlng.lng);

    if(mapMode === "start"){
      document.getElementById("startAddr").value = addr;

      if(startMarker) map.removeLayer(startMarker);
      startMarker = createDraggableMarker(e.latlng, "Start", async (p, a) => {
        document.getElementById("startAddr").value = a;
      });
      startMarker.openPopup();
    }

    if(mapMode === "ziel"){
      document.getElementById("endAddr").value = addr;

      if(endMarker) map.removeLayer(endMarker);
      endMarker = createDraggableMarker(e.latlng, "Ziel", async (p, a) => {
        document.getElementById("endAddr").value = a;
      });
      endMarker.openPopup();
    }

    if(mapMode === "stop"){
      const item = addStop(addr, e.latlng);
      if(item.marker) item.marker.openPopup();
    }

    mapMode = null;
  });

  // ---------------- Geocode / Reverse ----------------
  async function reverseGeocode(lat, lon){
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
    const res = await fetch(url, { headers: { "Accept": "application/json" } });
    const data = await res.json();
    return data.display_name || `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
  }

  async function geocodeOne(q){
    // allow "lat, lon"
    const m = q.match(/^\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*$/);
    if(m) return { lat: parseFloat(m[1]), lon: parseFloat(m[3]) };

    const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(q)}`;
    const res = await fetch(url, { headers: { "Accept": "application/json" } });
    const data = await res.json();
    if(!data || !data[0]) return null;
    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
  }

  // ---------------- Routing (OSRM - Auto) ----------------
  async function routeOSRM(coords){
    const coordStr = coords.map(c => `${c.lon},${c.lat}`).join(";");
    const url = `https://router.project-osrm.org/route/v1/driving/${coordStr}?overview=full&geometries=geojson&steps=false`;
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();
    if(!data.routes || !data.routes[0]) return null;
    return data.routes[0];
  }

  function km(m){ return (m/1000).toFixed(1); }
  function min(sec){ return Math.round(sec/60); }

  // ---------------- Build Route ----------------
  async function buildRoute(){
    metaEl.textContent = "";

    const startText = document.getElementById("startAddr").value.trim();
    const endText   = document.getElementById("endAddr").value.trim();

    if(!startText || !endText){
      metaEl.textContent = "Bitte Start und Ziel eingeben.";
      return;
    }

    // map line remove
    if(window.routeLine){
      map.removeLayer(window.routeLine);
      window.routeLine = null;
    }

    // Geocode start/end
    const start = await geocodeOne(startText);
    if(!start){ metaEl.textContent = "Start nicht gefunden."; return; }

    const stops = [];
    for(const item of stopItems){
      const t = item.inputEl.value.trim();
      if(!t) continue;
      const g = await geocodeOne(t);
      if(!g){ metaEl.textContent = `Stopp nicht gefunden: ${t}`; return; }
      stops.push(g);
    }

    const end = await geocodeOne(endText);
    if(!end){ metaEl.textContent = "Ziel nicht gefunden."; return; }

    const all = [start, ...stops, end];

    const r = await routeOSRM(all);
    if(!r){ metaEl.textContent = "Keine Route gefunden."; return; }

    window.routeLine = L.geoJSON(r.geometry, { style: { weight: 6, opacity: 0.95 } }).addTo(map);
    map.fitBounds(window.routeLine.getBounds().pad(0.15));

    metaEl.innerHTML = `Distanz: ${km(r.distance)} km<br>Zeit: ${min(r.duration)} min`;

    // OPTIONAL: update markers to geocoded positions (so they match exactly)
    // Start marker
    if(startMarker) map.removeLayer(startMarker);
    startMarker = createDraggableMarker([start.lat, start.lon], "Start", async (p, a) => {
      document.getElementById("startAddr").value = a;
    });

    // End marker
    if(endMarker) map.removeLayer(endMarker);
    endMarker = createDraggableMarker([end.lat, end.lon], "Ziel", async (p, a) => {
      document.getElementById("endAddr").value = a;
    });

    // Stop markers: clear existing and rebuild to match geocoded coords
    stopItems.forEach(si => { if(si.marker) map.removeLayer(si.marker); si.marker = null; });
    stopMarkers = [];

    // Attach markers to the stop items in order (only for non-empty stop inputs)
    let stopIndex = 0;
    for(const item of stopItems){
      const t = item.inputEl.value.trim();
      if(!t) continue;
      const g = stops[stopIndex++];
      item.marker = createDraggableMarker([g.lat, g.lon], "Stopp", async (p, a) => {
        item.inputEl.value = a;
      });
    }
  }
</script>

</body>
</html>
